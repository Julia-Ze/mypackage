% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitThresholdGP.R
\name{fitThresholdGP}
\alias{fitThresholdGP}
\title{Generalized Pareto GAMLSS Model for threshold excesses}
\usage{
fitThresholdGP(
  formula,
  xi.formula = formula,
  data,
  tau = 0.75,
  quantile.formula,
  mstop = 1000,
  replace = c("pb", "pbo", "pbp", "pbc", "cy", "pbm", "pbz", "ps", "pvc", "pvp"),
  scoring = c("fisher", "quasi"),
  sigma.link = "log",
  xi.link = "identity",
  stepLength = 1,
  stepAttempts = 2,
  stepReduce = 2,
  steps = FALSE,
  ...
)
}
\arguments{
\item{formula}{A formula object. See \code{\link[gamlss:gamlss]{gamlss::gamlss}}. In this context,
this could be named \code{sigma.formula} as it specifies the formula to be used
for the GP scale parameter \code{sigma}. This is passed to \code{\link[gamlss:gamlss]{gamlss::gamlss}}
as the argument \code{formula}.}

\item{xi.formula}{A formula object. Specifies the formula to be used for
the GP shape parameter \code{xi}. This is This is passed to \code{\link[gamlss:gamlss]{gamlss::gamlss}}
as the argument \code{sigma.formula} because \code{xi} is the second GP parameter.
The default setting is that \code{xi.formula} is the same as \code{formula}, that
is, the same formula is used for the GP scale \code{sigma} and shape \code{xi}.
To force a single value of \code{xi} to estimated for all observations use
\code{xi.formula = ~ 1}.}

\item{data}{a data frame containing the variables occurring in the formula, e.g. \code{data=aids}. If this is missing, the variables should be on the search list.}

\item{tau}{A numeric scalar \eqn{\tau} between 0 and 1 passed as the
argument \code{tau} to the \code{\link[mboost:Family]{Quantreg}}. The threshold is set
at an estimate of the \eqn{100\tau\%} conditional quantile of the response
given the values of the covariates.}

\item{quantile.formula}{A formula object to be passed to \code{\link{setThreshold}}.
If \code{quantile.formula} is supplied this this is the formula that is passed
to \code{\link[mboost:gamboost]{mboost::mboost}} to determine the form of the quantile regression
that sets the threshold. Otherwise, this formula is inferred from
the \code{formula} argument to \code{fitThresholdGP}, as described in \strong{Details}.}

\item{mstop}{The argument \code{mstop} to \code{\link[mboost:control]{mboost::boost_control}}.}

\item{replace}{A character vector. All instances of \code{pb()}, for example, in
\code{formula} will be replaced by \code{bbs()} for use in setting the threshold
using \code{\link[mboost:gamboost]{mboost::mboost}}. The default value of \code{replace}
contains the P-spline fitting functions in \code{\link[gamlss:ps]{gamlss::ps}}.

The special cases of the cyclic spline functions \code{pbc(.)} and \code{cy(.)} are
replaced by \code{bbs(., cyclic = TRUE)} and \code{bbs(., cyclic = TRUE)}
respectively.}

\item{scoring}{A character scalar. If \code{scoring = "fisher"} then the weights
used in the fitting algorithm are based on the expected Fisher
information, that is, a Fisher's scoring algorithm is used.
If \code{scoring = "quasi"} then these weights are based on the cross products
of the first derivatives of the log-likelihood, leading to a quasi Newton
scoring algorithm.}

\item{sigma.link, xi.link}{Character scalars to set the respective
link functions for the scale (\code{sigma}) and shape (\code{xi})
parameters. The latter (\code{xi.link}) is passed to
\code{\link[gamlss:gamlss]{gamlss::gamlss()}} as \code{sigma.link} because \code{xi} is the
second GP parameter.}

\item{stepLength}{A numeric vector of positive values. The initial
values of the step lengths \code{sigma.step} and \code{nu.step} passed to
\code{\link[gamlss:gamlss.control]{gamlss::gamlss.control()}} in the first attempt
to fit the model by calling \code{\link[gamlss:gamlss]{gamlss::gamlss()}}. If
\code{stepLength} has a length that is less than 2 then \code{stepLength} is
recycled to have length 2.}

\item{stepAttempts}{A non-negative integer. If the first call to
\code{\link[gamlss:gamlss]{gamlss::gamlss()}} throws an error then we make
\code{stepAttempts} further attempts to fit the model, each time dividing by 2
the values of \code{sigma.step} and \code{nu.step} supplied to
\code{\link[gamlss:gamlss.control]{gamlss::gamlss.control()}}. If
\code{stepAttempts < 1} then no further attempts are made.}

\item{stepReduce}{A number greater than 1. The factor by which the step
lengths in \code{stepLength} are reduced for each extra attempt to fit the
model. The default, \code{stepReduce = 2} means that the step lengths are
halved for each extra attempt.}

\item{steps}{A logical scalar. Pass \code{steps = TRUE} to write to the
console the current value of \code{stepLength} for each call to
\code{\link[gamlss:gamlss]{gamlss::gamlss()}}.}

\item{...}{Further arguments passed to \code{\link[gamlss:gamlss]{gamlss::gamlss}}, in particular
\code{method}, which sets the fitting algorithm, with options \code{RS()}, \code{CG()}
or \code{mixed()}. The default, \code{method = RS()} seems to work well, as does
\code{method = mixed()}. In contrast, \code{method = CG()} often requires the step
length to be reduced before convergence is achieved. \code{\link{fitGP}} attempts to
do this automatically. See \code{stepAttempts}. Pass \code{trace = FALSE}
(to \code{\link[gamlss:gamlss.control]{gamlss::gamlss.control}}) to avoid writing to the console the global
deviance after each outer iteration of the gamlss fitting algorithm.}
}
\value{
Returns a \code{gamlss} object. See the \strong{Value} section of
\code{\link[gamlss:gamlss]{gamlss::gamlss()}}. The class of the returned object is
\code{c("gamlssx", "gamlss", "gam", "glm", "lm")}.

The following components are added to the returned object list.
\itemize{
\item \code{data}: the input data \code{data}.
\item \code{exc_data}: a subset on \code{data} containing only rows for which the
response exceeds the threshold, that is, the threshold exceedances.
\item \verb{u, exc_u}: numeric vectors of threshold values for all the observations
(\code{u}) and only the threshold exceedances (\code{exc_u}).
\item \code{GPcall}: the call to \code{fitThresholdGP}.
\item \code{threshold}: the fitted threshold model object returned from \code{\link[mboost:gamboost]{mboost::mboost}}.
\item \code{p_exc}: the probability of threshold exceedance, equal to \code{1 - tau}.
}
}
\description{
Sets an extreme value threshold and then fits Generalized Additive Models
(GAMs) for Scale and Shape to threshold excesses with a GP response
distribution, using the function \code{\link[gamlss:gamlss]{gamlss::gamlss()}}.
}
\details{
The threshold is set using quantile regression. See
\code{\link{setThreshold}}, which uses the \code{QuantReg} family of the
\code{\link[mboost:gamboost]{mboost::mboost}} function. If \code{quantile.formula} is missing then the
form of the quantile regression model reflects the model formula in
\code{formula} to be used for the GP GAM. See the description of the argument
\code{replace}.

The Generalised Pareto (GP) GAM is fitted using
\code{\link[gamlss:gamlss]{gamlss::gamlss()}} based on the the \code{\link{GenPareto}} family.
}
\examples{
# Load gamlss
library(gamlss)

## Fit models to the waves data with 1 covariate

# Seasonal covariate only
fit1 <- fitThresholdGP(Hs ~ pbc(season), data = waves)
summary(fit1)
# gamlss provides some diagnostic plots
plot(fit1)

# Plot the data, the threshold and the GP fitted (mean) value
# (Just as a basic check that things look OK)
# (The warning about extrapolation can be ignored)
plot(waves$season, waves$Hs, xlab = "season", ylab = "Hs")
points(waves$season, fit1$u, col = "red", pch = 16)
newdata <- data.frame(season = waves$season)
sigma <- predict(fit1, newdata = newdata, what = "mu", type = "response")
xi <- predict(fit1, newdata = newdata, what = "sigma", type = "response")
fitted_median <- sigma * (2 ^ xi - 1) / xi
points(waves$season, fit1$u + fitted_median, col = "blue", pch = 16)
legend("top", legend = c("threshold u", "u + fitted GP median"), pch = 16,
       col = c("red", "blue"))

# Plot the fitted values of the GP scale and shape parameters
# Recall that, for gamlss, sigma is mu and xi is sigma
# (Eventually we could avoid this confusion, by creating our own wrapper
#  S3 method functions that use our preferred names.)
plot(fit1$data$season, sigma, xlab = "season", ylab = "GP scale")
plot(fit1$data$season, xi, xlab = "season", ylab = "GP shape")

# Directional covariate only
fit2 <- fitThresholdGP(Hs ~ pbc(direction), data = waves)
# We get a convergence warning, so start again from the estimates returned
# (We could also set up our function to rename the 'start' arguments.
#  Likewise sigma.fix and xi.fix.)
fit2 <- fitThresholdGP(Hs ~ pbc(direction), data = waves,
                       mu.start = fitted(fit2, what = "mu"),
                       sigma.start = fitted(fit2, what = "sigma"))
summary(fit2)

# Plot the data, the threshold and the GP fitted (mean) value
# (Just as a basic check that things look OK)
# (The warning about extrapolation can be ignored)
plot(waves$direction, waves$Hs, xlab = "direction", ylab = "Hs")
points(waves$direction, fit2$u, col = "red", pch = 16)
newdata <- data.frame(direction = waves$direction)
sigma <- predict(fit2, newdata = newdata, what = "mu", type = "response")
xi <- predict(fit2, newdata = newdata, what = "sigma", type = "response")
fitted_median <- sigma * (2 ^ xi - 1) / xi
points(waves$direction, fit2$u + fitted_median, col = "blue", pch = 16)
legend("top", legend = c("threshold u", "u + fitted GP median"), pch = 16,
       col = c("red", "blue"))

# Plot the fitted values of the GP scale and shape parameters
# Recall that, for gamlss, sigma is mu and xi is sigma
# (Eventually we could avoid this confusion, by creating our own wrapper
#  S3 method functions that use our preferred names.)
plot(fit2$data$direction, sigma, xlab = "direction", ylab = "GP scale")
plot(fit2$data$direction, xi, xlab = "direction", ylab = "GP shape")

## Fit models to the waves data with 2 covariates

# Main effects for Seasonal and directional covariates only

# Note: when using this model we assume that the effect of season is the
# same for different values of direction and vice versa
fit3 <- fitThresholdGP(Hs ~ pbc(direction) + pbc(season), data = waves)
summary(fit3)

directions <- 0:360

# Estimated effect of direction in January
mid_january <- data.frame(direction = directions, season = 0.5 / 12)
xi_january <- predict(fit3, newdata = mid_january, what = "sigma",
                      type = "response")
plot(directions, xi_january, type = "l", xlab = "direction", ylab = "xi",
     main = "January", lwd = 2)

# Estimated effect of direction in July
mid_july <- data.frame(direction = directions, season = 6.5 / 12)
xi_july <- predict(fit3, newdata = mid_july, what = "sigma",
                   type = "response")
plot(directions, xi_july, type = "l", xlab = "direction", ylab = "xi",
     main = "July", lwd = 2)

# The rgl package is required for the following plot
# This is just for fun and in case it helps to see that direction has no
# influence on the estimated effect of season and vice versa
rgl::plot3d(waves$season, waves$direction, fit3$u)

#' # How to calculate the threshold for a storm that arrives mid-January
# from direction 250
newdata <- data.frame(season = 0.5 / 12, direction = 250)
predict(fit3$threshold, newdata = newdata)

# How to calculate the fitted values of the GP scale and shape parameters
# type = "response" accounts for the (log) link for the scale parameter
predict(fit3, what = "mu", newdata = newdata, type = "response")
predict(fit3, what = "sigma", newdata = newdata)

# Load mgcv and gamlss.add because we need them for what follows
library(mgcv)
library(gamlss.add)

# See ?ga and ?te
# More details in Section 9.5 of the gamlss book
# 2D effects of direction and season, constrained so that the effects of
# both are cyclical, that is, they are constrained on the boundary of a
# rectangle.
# We use quantile.formula to set the threshold using an equivalent approach
# We set tau = 0.5 because this is what Northrop, Jonathan and Randell (2016)
# did.
# (Note that their results are rather different, especially for xi.
#  This isn't surprising because they took a different approach in some
#  areas. )
fit4 <- fitThresholdGP(Hs ~ ga(~te(direction, season, bs = "cc"),
                       knots=list(direction = c(0, 360), season = c(0, 1))),
                       data = waves, tau = 0.5,
                       quantile.formula =
                       Hs ~ bbs(direction, season, cyclic = TRUE))

# I don't think that the type = "response" argument works here because
# some of the contours for "mu" (our "sigma") have negative values
vis.gam(getSmo(fit4, what = "mu"), type = "response", plot.type = "contour")
# I also don't believe the numbers of the plot for xi
vis.gam(getSmo(fit4, what = "sigma"), plot.type = "contour")

# These numbers aren't correct either
term.plot(fit4)
term.plot(fit4, what = "sigma")

# These numbers are correct I think
# Get fitted values for xi 'by hand'
p <- fitted(fit4, what = "mu")
summary(p)
p <- fitted(fit4, what = "sigma")
summary(p)
}
\seealso{
\code{\link{GenPareto}}, \code{\link{fitGP}}, \code{\link{setThreshold}},
\code{\link[gamlss.dist:gamlss.family]{gamlss.dist::gamlss.family()}},
\code{\link[gamlss:gamlss]{gamlss::gamlss()}}
}
